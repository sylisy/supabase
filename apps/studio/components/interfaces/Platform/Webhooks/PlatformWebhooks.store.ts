import { useState } from 'react'

import { PLATFORM_WEBHOOKS_MOCK_DATA } from './PlatformWebhooks.mock'
import type {
  PlatformWebhooksState,
  UpsertWebhookEndpointInput,
  WebhookDelivery,
  WebhookEndpoint,
  WebhookScope,
} from './PlatformWebhooks.types'

interface CreateEndpointOptions {
  now?: string
  endpointId?: string
  createdBy?: string
  signingSecret?: string
}

interface UpdateEndpointOptions {
  headerIdFactory?: () => string
}

const randomId = (prefix: string) => `${prefix}-${Math.random().toString(36).slice(2, 10)}`

const generateSigningSecret = () => `whsec_${Math.random().toString(36).slice(2, 18)}`

const deepClone = <T,>(value: T): T => JSON.parse(JSON.stringify(value))

const toHeaders = (
  headers: UpsertWebhookEndpointInput['customHeaders'],
  options?: UpdateEndpointOptions
) => {
  const headerIdFactory = options?.headerIdFactory ?? (() => randomId('header'))
  return headers
    .map((header) => ({
      id: headerIdFactory(),
      key: header.key.trim(),
      value: header.value.trim(),
    }))
    .filter((header) => header.key.length > 0 && header.value.length > 0)
}

const normalizeSearch = (value: string) => value.trim().toLowerCase()

export const createInitialPlatformWebhooksState = (scope: WebhookScope): PlatformWebhooksState => {
  const seed = PLATFORM_WEBHOOKS_MOCK_DATA[scope]
  return {
    endpoints: deepClone(seed.endpoints),
    deliveries: deepClone(seed.deliveries),
  }
}

export const createWebhookEndpoint = (
  state: PlatformWebhooksState,
  input: UpsertWebhookEndpointInput,
  options?: CreateEndpointOptions
): { state: PlatformWebhooksState; endpoint: WebhookEndpoint } => {
  const endpointId = options?.endpointId ?? randomId('endpoint')
  const internalName = input.name.trim().length > 0 ? input.name.trim() : endpointId
  const endpoint: WebhookEndpoint = {
    id: endpointId,
    name: internalName,
    url: input.url.trim(),
    description: input.description.trim(),
    enabled: input.enabled,
    eventTypes: input.eventTypes.length > 0 ? input.eventTypes : ['*'],
    customHeaders: toHeaders(input.customHeaders),
    signingSecret: options?.signingSecret ?? generateSigningSecret(),
    createdBy: options?.createdBy ?? 'mock-user@supabase.io',
    createdAt: options?.now ?? new Date().toISOString(),
  }

  return {
    endpoint,
    state: {
      ...state,
      endpoints: [endpoint, ...state.endpoints],
    },
  }
}

export const updateWebhookEndpoint = (
  state: PlatformWebhooksState,
  endpointId: string,
  input: UpsertWebhookEndpointInput,
  options?: UpdateEndpointOptions
) => {
  return {
    ...state,
    endpoints: state.endpoints.map((endpoint) =>
      endpoint.id === endpointId
        ? {
            ...endpoint,
            name: input.name.trim().length > 0 ? input.name.trim() : endpoint.name,
            url: input.url.trim(),
            description: input.description.trim(),
            enabled: input.enabled,
            eventTypes: input.eventTypes.length > 0 ? input.eventTypes : ['*'],
            customHeaders: toHeaders(input.customHeaders, options),
          }
        : endpoint
    ),
  }
}

export const deleteWebhookEndpoint = (state: PlatformWebhooksState, endpointId: string) => {
  return {
    endpoints: state.endpoints.filter((endpoint) => endpoint.id !== endpointId),
    deliveries: state.deliveries.filter((delivery) => delivery.endpointId !== endpointId),
  }
}

export const toggleWebhookEndpoint = (
  state: PlatformWebhooksState,
  endpointId: string,
  enabled?: boolean
) => {
  return {
    ...state,
    endpoints: state.endpoints.map((endpoint) =>
      endpoint.id === endpointId
        ? { ...endpoint, enabled: enabled === undefined ? !endpoint.enabled : enabled }
        : endpoint
    ),
  }
}

export const regenerateWebhookEndpointSecret = (
  state: PlatformWebhooksState,
  endpointId: string,
  secret?: string
) => {
  return {
    ...state,
    endpoints: state.endpoints.map((endpoint) =>
      endpoint.id === endpointId
        ? { ...endpoint, signingSecret: secret ?? generateSigningSecret() }
        : endpoint
    ),
  }
}

export const filterWebhookEndpoints = (endpoints: WebhookEndpoint[], search: string) => {
  const normalizedSearch = normalizeSearch(search)
  if (normalizedSearch.length === 0) return endpoints

  return endpoints.filter((endpoint) => {
    const haystack = `${endpoint.name} ${endpoint.url} ${endpoint.description}`.toLowerCase()
    return haystack.includes(normalizedSearch)
  })
}

export const filterWebhookDeliveries = (
  deliveries: WebhookDelivery[],
  endpointId: string,
  search: string
) => {
  const normalizedSearch = normalizeSearch(search)

  return deliveries
    .filter((delivery) => delivery.endpointId === endpointId)
    .filter((delivery) => {
      if (normalizedSearch.length === 0) return true
      const haystack = `${delivery.eventType} ${delivery.status} ${delivery.responseCode ?? ''}`.toLowerCase()
      return haystack.includes(normalizedSearch)
    })
}

export const usePlatformWebhooksMockStore = (scope: WebhookScope) => {
  const [state, setState] = useState<PlatformWebhooksState>(() =>
    createInitialPlatformWebhooksState(scope)
  )

  return {
    ...state,
    createEndpoint: (input: UpsertWebhookEndpointInput) => {
      const endpointId = randomId('endpoint')
      const now = new Date().toISOString()
      const signingSecret = generateSigningSecret()
      const createdBy = 'mock-user@supabase.io'
      setState((prev) =>
        createWebhookEndpoint(prev, input, {
          endpointId,
          now,
          signingSecret,
          createdBy,
        }).state
      )
      return endpointId
    },
    updateEndpoint: (endpointId: string, input: UpsertWebhookEndpointInput) => {
      setState((prev) => updateWebhookEndpoint(prev, endpointId, input))
    },
    deleteEndpoint: (endpointId: string) => {
      setState((prev) => deleteWebhookEndpoint(prev, endpointId))
    },
    toggleEndpoint: (endpointId: string, enabled?: boolean) => {
      setState((prev) => toggleWebhookEndpoint(prev, endpointId, enabled))
    },
    regenerateSecret: (endpointId: string) => {
      setState((prev) => regenerateWebhookEndpointSecret(prev, endpointId))
    },
  }
}

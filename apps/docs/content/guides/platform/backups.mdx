---
title: 'Database Backups'
description: 'Learn about backups for your Supabase project.'
---

Database backups are an integral part of any disaster recovery plan. Disasters come in many shapes and sizes—from accidentally deleting a table column, to the database crashing, to a natural calamity wiping out the underlying hardware. You can never fully eliminate the risks and impact of these scenarios, but you can minimize or mitigate them. Database backups act as a form of insurance policy. They are essentially snapshots of the database at various points in time. When disaster strikes, you can use database backups to restore the project to any of these points in time, averting the crisis.

We automatically back up all Free, Pro, Team, and Enterprise Plan projects on a daily basis. You can find backups in the [**Database** > **Backups**](/dashboard/project/_/database/backups/scheduled) section of the Dashboard.

Pro Plan projects can access the last 7 days of daily backups. Team Plan projects can access the last 14 days of daily backups, while Enterprise Plan projects can access up to 30 days of daily backups. If you need more frequent backups, consider enabling [Point-in-Time Recovery](#point-in-time-recovery).

<Admonition type="caution">

When you delete a project, we permanently remove all associated data, including any backups stored in S3. This action is irreversible, so consider it carefully before proceeding.

</Admonition>

<Admonition type="note">

Database backups do not include objects you store via the Storage API, as the database only includes metadata about these objects. Restoring an old backup does not restore objects you deleted after that backup.

</Admonition>

<Admonition type="caution">

For security purposes, daily backups do not store passwords for custom roles, and you will not find them in downloadable files. If you restore from a daily backup and use custom roles, you will need to reset their passwords after the restoration completes.

</Admonition>

## Backup and restore process

We use the Postgres utility [pg_dumpall](https://www.postgresql.org/docs/current/app-pg-dumpall.html) to perform daily backups. We generate an SQL file, zip it up, and send it to storage servers for safekeeping.

You can access daily backups in the [**Database** > **Backups**](/dashboard/project/_/database/backups/scheduled) section of the Dashboard and restore a project to any one of the backups.

You can restore your project to any of these backups. To generate a logical backup yourself, use the [Supabase CLI `db dump` command](/docs/reference/cli/supabase-db-dump).

## Managing backups programmatically

You can also manage backups programmatically using the Management API:

```bash
# Get your access token from https://supabase.com/dashboard/account/tokens
export SUPABASE_ACCESS_TOKEN="your-access-token"
export PROJECT_REF="your-project-ref"

# List all available backups
curl -H "Authorization: Bearer $SUPABASE_ACCESS_TOKEN" \
  "https://api.supabase.com/v1/projects/$PROJECT_REF/database/backups"

# Restore from a PITR backup (replace ISO timestamp with desired restore point)
curl -X POST "https://api.supabase.com/v1/projects/$PROJECT_REF/database/backups/restore-pitr" \
  -H "Authorization: Bearer $SUPABASE_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "recovery_time_target_unix": "1735689600"
  }'
```

### Restoration process

When selecting a backup to restore to, choose the closest available backup made before your desired restore point. You can always choose earlier backups, but consider how many days of data you might lose.

The Dashboard prompts you for confirmation before proceeding with the restoration. The project is inaccessible during this process, so plan for downtime beforehand. Downtime depends on the size of the database—the larger it is, the longer the downtime will be. After you confirm, we run the underlying SQL of the chosen backup against the project. We use the Postgres utility [psql](https://www.postgresql.org/docs/current/app-psql.html) to facilitate the restoration. The Dashboard will display a notification once the restoration completes.

If your project uses subscriptions or replication slots, you need to drop them before the restoration and re-create them afterward. We exempt the slot used by Realtime from this requirement and handle it automatically.

{/* screenshot of the Dashboard of the project completing restoration */}

## Point-in-Time recovery

Point-in-Time Recovery (PITR) allows you to back up a project at shorter intervals, giving you the option to restore to any chosen point with up to seconds of granularity. Even with daily backups, you could still lose a day's worth of data. With PITR, you can back up to the point of disaster.

<Admonition type="note">

Pro, Team and Enterprise Plan projects can enable PITR as an add-on.

Projects that want to use PITR must also use at least a Small compute add-on to ensure smooth functioning.

</Admonition>
{/* TODO: Maybe sub-head */}
<Accordion
  type="default"
  openBehaviour="multiple"
  chevronAlign="right"
  justified
  size="medium"
  className="text-foreground-light mt-8 mb-6"
>
  <div className="border-b mt-3 pb-3">
    <AccordionItem
      header="How PITR works"
      id="item-1"
    >

    As [covered in this blog post](/blog/postgresql-physical-logical-backups), a combination of physical backups and [Write Ahead Log (WAL)](https://www.postgresql.org/docs/current/wal-intro.html) file archiving makes PITR possible. Physical backups provide a snapshot of the underlying directory of the database, while WAL files contain records of every change the database processes.

    We use [WAL-G](https://github.com/wal-g/wal-g), an open source archival and restoration tool, to handle both aspects of PITR. Daily, we take a snapshot of the database and send it to our storage servers. Throughout the day, as database transactions occur, we generate and upload WAL files.

    By default, we back up WAL files at two-minute intervals. If these files exceed a certain file size threshold, we back them up immediately. During periods of high transaction volume, WAL file backups therefore become more frequent. Conversely, when the database has no activity, we do not make WAL file backups. Overall, in the worst case scenario, PITR achieves a Recovery Point Objective (RPO) of two minutes.

    </AccordionItem>

  </div>
</Accordion>

<Admonition type="note">

If you enable PITR, we will no longer take Daily Backups. PITR provides finer granularity than Daily Backups, so running both is unnecessary.

If you disabled PITR, logical backups remain available until they pass the backup retention period for your plan. After that window passes, we will only show physical backups.

</Admonition>

### Backup process

![PITR dashboard](/docs/img/backups-pitr-dashboard.png)

You can access PITR in the [Point in Time](/dashboard/project/_/database/backups/pitr) settings in the Dashboard. The recovery period of a project is shown by the earliest and latest recovery points displayed in your preferred timezone. You can change the maximum recovery period if needed.

The latest restore point of the project could be significantly behind the current time. This occurs when the database has had no recent activity, and therefore we have not made any recent WAL file backups. However, the state of the database at the latest recovery point still reflects the current state of the database, given that no transactions have occurred in between.

### Restoration process

![PITR: Calendar view](/docs/img/backups-pitr-calendar-view.png)

A date and time picker appears when you press the **Start a restore** button. The process only proceed if the selected date and time fall within the earliest and latest recovery points.

![PITR: Confirmation modal](/docs/img/backups-pitr-confirmation-modal.png)

After selecting your desired recovery point, the Dashboard prompts you to review and confirm before proceeding with the restoration. The project is inaccessible during this process, so plan for downtime beforehand. Downtime depends on the size of the database—the larger it is, the longer the downtime will be. After you confirm, we download the latest available physical backup to the project and partially restore the database. We then download the WAL files generated after this physical backup up to your specified point in time. We replay the underlying transaction records in these files against the database to complete the restoration. The Dashboard will display a notification once the restoration completes.

<$Show if="billing:all">
<$Partial path="billing/pricing/pricing_pitr.mdx" />
</$Show>

### Downloading backups after disabling PITR

When you disable PITR, we still take all new backups as physical backups only. You can still use physical backups for restoration, but they are not available for direct download. If you need to download a backup after disabling PITR, you need to take a manual [legacy logical backup using the Supabase CLI or pg_dump](/docs/guides/platform/migrating-within-supabase/backup-restore#backup-database-using-the-cli).

## Restore to a new project

See the [Duplicate Project docs](/docs/guides/platform/clone-project).

## Troubleshooting

### Logical backups

#### `search_path` issues

During the `pg_restore` process, the restore process sets the `search_path` to an empty string for predictability and security. Using unqualified references to functions or relations can cause logical backup restorations to fail, because the database cannot locate the referenced function or relation. This can happen even when the database functions without issues during normal operations, since Postgres usually sets the `search_path` to include several schemas during normal operations. Always use schema-qualified names in your SQL code.

You can refer to [an example PR](https://github.com/supabase/supabase/pull/28393/files) on how to update SQL code to use schema-qualified names.

#### Invalid check constraints

Postgres requires that [check constraints](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-CHECK-CONSTRAINTS) be:

1. immutable
1. not reference table data other than the new or updated row being checked

Violating these requirements can result in numerous failure scenarios, including during logical restorations.

Common examples of check constraints that can cause such failures include:

- validating against the current time, e.g. that the row being inserted references a future event
- validating the contents of a row against the contents of another table

#### Views that reference themselves

Views that directly or indirectly reference themselves will cause logical restores to fail due to cyclic dependency errors. These views are also invalid and unusable in Postgres—any query against them will result in a runtime error.

**Example:**

```
-- Direct self-reference
CREATE VIEW my_view AS
  SELECT * FROM my_view;

-- Indirect circular reference
CREATE VIEW v1 AS SELECT * FROM v2;
CREATE VIEW v2 AS SELECT * FROM v1;
```

-- Drop the offending view from your database, or delete it from the logical backup to make it restorable.

Postgres documentation [views](https://www.postgresql.org/docs/current/sql-createview.html)
